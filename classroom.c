#pragma config(Sensor, S3,     light,          sensorLightActive)
#pragma config(Sensor, S1,     touch,          sensorTouch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
// 48 threshold

int check_student(void);
void next_row(void);
void pivot_turn(float degrees);
void forward(float revolutions);
void forward_cm(float cm);
void set_motors(int b, int c);

const int threshold = 48;

task main()
{
	int count = 0;

	// get to the first row
	while (SensorValue(light) <= threshold) {
		set_motors(30, 30);
	}
	set_motors(0, 0);
	pivot_turn(90);

	// check first row
	count = count + check_student();

	next_row();
	count = count + check_student();

	next_row();
	count = count + check_student();

	// get back
	forward_cm(20);
	pivot_turn(90);
	for (int i = 0; i < 3; i++) {
		while (SensorValue(light) <= threshold) {
			set_motors(30, 30);
		}
		while (SensorValue(light) >= threshold) {
			set_motors(30, 30);
		}
	}
	set_motors(0, 0);

	nxtDisplayBigTextLine(2, "%d", count);
	nVolume = 5;
	for (int i = 0; i < count; i++) {
		playSound(soundShortBlip);
		wait1Msec(500);
		clearSounds();
	}
	wait1Msec(60000);
}

int check_student(void) {
	int students = 0;
	int count = 0;
	int lines = 2;
	while (SensorValue(touch) == 0 && count < lines) {
		set_motors(30, 30);
		if (SensorValue(light) >= threshold && count < lines) {
			count++;
			while (SensorValue(light) >= threshold && count < lines) {
				set_motors(30, 30);
			}
		}
	}
	if (SensorValue(touch) == 1) {
		students++;
	}
	set_motors(0, 0);
	wait1Msec(200);
	forward_cm(-4);
	wait1Msec(200);
	pivot_turn(180);
	wait1Msec(200);

	lines = (students == 1) ? 2 : 3;
	count = 0;
	while (SensorValue(touch) == 0 && count < lines) {
		set_motors(30, 30);
		if (SensorValue(light) >= threshold && count < lines) {
			count++;
			while (SensorValue(light) >= threshold && count < lines) {
				set_motors(30, 30);
			}
		}
	}
	if (SensorValue(touch) == 1) {
		students++;
	}
	set_motors(0, 0);
	wait1Msec(200);
	forward_cm(-4);
	wait1Msec(200);
	pivot_turn(180);
	wait1Msec(200);
	return students;
}

void next_row(void) {
	forward_cm(30);
	pivot_turn(-90);
	forward_cm(-5);
	while (SensorValue(light) <= threshold) {
		set_motors(30, 30);
	}
	while (SensorValue(light) >= threshold) {
		set_motors(30, 30);
	}
	while (SensorValue(light) <= threshold) {
		set_motors(30, 30);
	}
	set_motors(0, 0);
	wait1Msec(200);
	pivot_turn(90);
	wait1Msec(200);
}


void pivot_turn(float degrees) {
	nSyncedMotors = synchBC;
	nSyncedTurnRatio = -100;

	nMotorEncoder[motorB] = 0;
	nMotorEncoderTarget[motorB] = 350 * (degrees/180);
	motor[motorB] = (degrees >= 0) ? 30 : -30;

	while(nMotorRunState[motorB] != runStateIdle) {}

	nSyncedMotors = synchNone;
	motor[motorB] = 0;

	wait1Msec(300);
}

void forward(float revolutions) {
	nSyncedMotors = synchBC;
	nMotorEncoder[motorB] = 0;
	nMotorEncoderTarget[motorB] = revolutions * 360;

	nSyncedTurnRatio = 100;
	motor[motorB] = (revolutions > 0) ? 30 : -30;

	while(nMotorRunState[motorB] != runStateIdle) {}
	wait1Msec(200);
}

void forward_cm(float cm) {
	forward((5 * (cm / 90)) * 100/98);
}

void set_motors(int b, int c) {
	motor[motorB] = b;
	motor[motorC] = c;
}
